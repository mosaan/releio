# ユースケース実現（UC-01, UC-04）―方向づけフェーズ版

アーキテクチャ上重要と判断したユースケース2件について、方向づけフェーズ向けの荒削りな実現シナリオを示します。バウンダリ/コントロール/エンティティは分析モデル（`docs_UP/分析_分析モデル.md`）に対応します。

## UC-01: AIと会話する（ストリーミング + MCPツール呼び出し）

### シナリオ概要
- ユーザーがチャット画面からメッセージを送信する。
- RendererはBackendへストリーミング要求を送り、Backendがモデル選択・MCPツール連携を調停する。
- AIプロバイダーからのトークンとツール呼び出し要求を逐次UIへ反映し、永続化する。

### シーケンス（ラフ）
```plantuml
@startuml
actor User
participant ChatUI <<boundary>>
participant RendererChatController <<control>>
participant ConversationController <<control>>
participant SessionController <<control>>
participant MCPController <<control>>
participant "AI Provider" as AI <<entity>>
participant "MCP Server" as MCP <<entity>>

User -> ChatUI : 1. メッセージ入力
ChatUI -> RendererChatController : 2. sendMessage(sessionId, text)
RendererChatController -> SessionController : 3. ユーザーメッセージ保存(pending)
RendererChatController -> ConversationController : 4. streamAIText(messages, modelSelection)
ConversationController -> MCPController : 5. 使用可能ツールの収集
ConversationController -> AI : 6. ストリーミング開始(messages, tools)
AI --> ConversationController : 7. トークン/ツール呼び出し要求
ConversationController -> ChatUI : 8. ストリームイベント中継
ConversationController -> SessionController : 9. assistantメッセージを更新(streaming/ログ)

alt ツール呼び出しがある場合
  ConversationController -> MCPController : 10. callTool(serverId, tool, args)
  MCPController -> MCP : 11. ツール実行(stdio)
  MCP --> MCPController : 12. 実行結果/エラー
  MCPController --> ConversationController : 13. ツール結果
  ConversationController -> AI : 14. ツール結果をAIへ返送
end

ConversationController -> SessionController : 15. 完了状態・トークン数を保存
ConversationController -> ChatUI : 16. 最終レスポンス表示（streaming→completed）
@enduml
```

### 留意点
- モデル選択とAPIキー解決は`AISettingsV2`（プロバイダー設定）を優先し、Fallbackとして旧設定を使う。
- コンテキスト長の確認と圧縮判断は`CompressionController`が行い、必要に応じてスナップショットを追加する。
- 失敗時はストリーム停止・エラーイベントを即時UIに返し、セッション側にエラーを記録する。

## UC-04: MCPサーバーを管理する（登録と起動）

### シナリオ概要
- ユーザーがMCPサーバー設定を追加・有効化し、提供ツール/リソースを取得する。
- Backendがサーバープロセスを起動し、状態変化をRendererへ通知する。

### シーケンス（ラフ）
```plantuml
@startuml
actor User
participant SettingsUI <<boundary>>
participant RendererSettingsController <<control>>
participant MCPController <<control>>
database "DB" as DB
participant "MCP Server Process" as MCP <<entity>>

User -> SettingsUI : 1. サーバー情報入力(command, args, env, enabled)
SettingsUI -> RendererSettingsController : 2. 保存要求
RendererSettingsController -> MCPController : 3. add/updateMCPServer(config)
MCPController -> DB : 4. 設定を永続化
MCPController -> MCP : 5. 有効サーバーを起動(stdio接続)
MCPController -> SettingsUI : 6. ステータス通知(connected/stopped/error)
SettingsUI -> MCPController : 7. listTools/listResources
MCPController -> MCP : 8. ツール/リソース取得
MCP --> MCPController : 9. 定義・stderr詳細
MCPController --> SettingsUI : 10. 一覧表示・デバッグ情報
@enduml
```

### 留意点
- サーバーごとの状態（connected/stopped/error）は`statusEmitter`経由で全Rendererへブロードキャストされる。
- stderr/exitコードなどのデバッグ情報は、エラー時にUIへ返却し設定見直しを促す。
- AIストリーミングは有効なMCPツール一覧を毎回集約するため、UC-01とUC-04の連携点としてMCP設定の正確性が重要。
